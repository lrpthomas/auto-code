"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedGenerator = void 0;
const postgresql_1 = require("../postgresql");
class SeedGenerator {
    generator;
    faker;
    constructor(generator) {
        this.generator = generator;
        this.initializeFaker();
    }
    initializeFaker() {
        // Placeholder for faker initialization
        // In real implementation, would use @faker-js/faker
        this.faker = {
            person: {
                firstName: () => 'John',
                lastName: () => 'Doe',
                fullName: () => 'John Doe'
            },
            internet: {
                email: () => 'test@example.com',
                url: () => 'https://example.com',
                password: () => 'password123'
            },
            lorem: {
                sentence: () => 'Lorem ipsum dolor sit amet.',
                paragraph: () => 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.'
            },
            datatype: {
                number: (options) => Math.floor(Math.random() * 100),
                boolean: () => Math.random() > 0.5,
                uuid: () => '123e4567-e89b-12d3-a456-426614174000'
            },
            date: {
                recent: () => new Date(),
                past: () => new Date(Date.now() - 86400000),
                future: () => new Date(Date.now() + 86400000)
            },
            company: {
                name: () => 'Acme Corp',
                buzzPhrase: () => 'Innovative solutions'
            },
            commerce: {
                productName: () => 'Widget',
                price: () => '99.99',
                department: () => 'Electronics'
            }
        };
    }
    async generateSeeds(template, configs) {
        const seedData = {};
        // Generate data for each table
        for (const config of configs) {
            const table = template.tables.find(t => t.name === config.table);
            if (!table) {
                throw new Error(`Table ${config.table} not found in template`);
            }
            if (config.data) {
                seedData[config.table] = config.data;
            }
            else {
                seedData[config.table] = this.generateTableData(table, config);
            }
        }
        return await this.generator.generateSeeds(template, seedData);
    }
    generateTableData(table, config) {
        const data = [];
        for (let i = 0; i < config.count; i++) {
            const record = {};
            for (const field of table.fields) {
                // Skip auto-generated fields
                if (this.isAutoGeneratedField(field))
                    continue;
                record[field.name] = this.generateFieldValue(field, i, config);
            }
            data.push(record);
        }
        return data;
    }
    isAutoGeneratedField(field) {
        const autoFields = ['id', 'created_at', 'updated_at'];
        return autoFields.includes(field.name.toLowerCase()) ||
            field.constraints?.some(c => c.type === 'primary') ||
            field.default !== undefined;
    }
    generateFieldValue(field, index, config) {
        // Check for relation configuration
        const relation = config.relations?.find(r => r.field === field.name);
        if (relation) {
            return this.generateRelationValue(relation, index);
        }
        // Generate value based on field type
        switch (field.type) {
            case 'string':
                return this.generateStringValue(field);
            case 'text':
                return this.generateTextValue(field);
            case 'integer':
            case 'bigint':
                return this.generateIntegerValue(field);
            case 'decimal':
                return this.generateDecimalValue(field);
            case 'boolean':
                return this.faker.datatype.boolean();
            case 'date':
            case 'datetime':
            case 'timestamp':
                return this.generateDateValue(field);
            case 'json':
                return this.generateJsonValue(field);
            case 'uuid':
                return this.faker.datatype.uuid();
            default:
                return null;
        }
    }
    generateRelationValue(relation, index) {
        switch (relation.strategy) {
            case 'fixed':
                return relation.value;
            case 'sequential':
                return index + 1;
            case 'random':
            default:
                return this.faker.datatype.number({ min: 1, max: 100 });
        }
    }
    generateStringValue(field) {
        const fieldName = field.name.toLowerCase();
        if (fieldName.includes('email')) {
            return this.faker.internet.email();
        }
        else if (fieldName.includes('name')) {
            if (fieldName.includes('first')) {
                return this.faker.person.firstName();
            }
            else if (fieldName.includes('last')) {
                return this.faker.person.lastName();
            }
            else {
                return this.faker.person.fullName();
            }
        }
        else if (fieldName.includes('url') || fieldName.includes('website')) {
            return this.faker.internet.url();
        }
        else if (fieldName.includes('password')) {
            return this.faker.internet.password();
        }
        else if (fieldName.includes('company')) {
            return this.faker.company.name();
        }
        else if (fieldName.includes('product')) {
            return this.faker.commerce.productName();
        }
        else {
            return this.faker.lorem.sentence();
        }
    }
    generateTextValue(field) {
        const fieldName = field.name.toLowerCase();
        if (fieldName.includes('description') || fieldName.includes('bio')) {
            return this.faker.lorem.paragraph();
        }
        else {
            return this.faker.lorem.paragraph();
        }
    }
    generateIntegerValue(field) {
        const fieldName = field.name.toLowerCase();
        if (fieldName.includes('age')) {
            return this.faker.datatype.number({ min: 18, max: 80 });
        }
        else if (fieldName.includes('price') || fieldName.includes('amount')) {
            return this.faker.datatype.number({ min: 1, max: 10000 });
        }
        else if (fieldName.includes('quantity') || fieldName.includes('count')) {
            return this.faker.datatype.number({ min: 1, max: 100 });
        }
        else {
            return this.faker.datatype.number({ min: 1, max: 1000 });
        }
    }
    generateDecimalValue(field) {
        const fieldName = field.name.toLowerCase();
        if (fieldName.includes('price') || fieldName.includes('amount') || fieldName.includes('cost')) {
            return parseFloat(this.faker.commerce.price());
        }
        else if (fieldName.includes('rate') || fieldName.includes('percentage')) {
            return parseFloat((Math.random() * 100).toFixed(2));
        }
        else {
            return parseFloat((Math.random() * 1000).toFixed(2));
        }
    }
    generateDateValue(field) {
        const fieldName = field.name.toLowerCase();
        if (fieldName.includes('birth') || fieldName.includes('dob')) {
            return this.faker.date.past();
        }
        else if (fieldName.includes('expire') || fieldName.includes('due')) {
            return this.faker.date.future();
        }
        else if (fieldName.includes('created')) {
            return this.faker.date.past();
        }
        else if (fieldName.includes('updated')) {
            return this.faker.date.recent();
        }
        else {
            return this.faker.date.recent();
        }
    }
    generateJsonValue(field) {
        const fieldName = field.name.toLowerCase();
        if (fieldName.includes('settings') || fieldName.includes('config')) {
            return {
                theme: 'light',
                notifications: true,
                language: 'en'
            };
        }
        else if (fieldName.includes('metadata') || fieldName.includes('data')) {
            return {
                key1: 'value1',
                key2: 'value2',
                timestamp: new Date().toISOString()
            };
        }
        else {
            return {
                generated: true,
                timestamp: new Date().toISOString()
            };
        }
    }
    generateSeedTemplate(template) {
        return template.tables.map(table => ({
            table: table.name,
            count: 10, // Default count
            relations: this.generateRelationConfigs(table)
        }));
    }
    generateRelationConfigs(table) {
        const relations = [];
        if (table.relationships) {
            for (const rel of table.relationships) {
                relations.push({
                    field: rel.foreignKey,
                    table: rel.table,
                    strategy: 'random'
                });
            }
        }
        return relations;
    }
    async generateFactoryFile(template) {
        const isPostgres = this.generator instanceof postgresql_1.PostgreSQLGenerator;
        if (isPostgres) {
            return this.generatePostgresFactory(template);
        }
        else {
            return this.generateMongoFactory(template);
        }
    }
    generatePostgresFactory(template) {
        let factory = `// Database Factory for ${template.name}\n`;
        factory += `import { faker } from '@faker-js/faker';\n`;
        factory += `import { DatabasePool } from '../connection-pool';\n\n`;
        for (const table of template.tables) {
            factory += `export class ${this.toPascalCase(table.name)}Factory {\n`;
            factory += `  static async create(overrides: Partial<any> = {}): Promise<any> {\n`;
            factory += `    const data = {\n`;
            for (const field of table.fields) {
                if (this.isAutoGeneratedField(field))
                    continue;
                factory += `      ${field.name}: ${this.generateFactoryFieldValue(field)},\n`;
            }
            factory += `      ...overrides\n`;
            factory += `    };\n\n`;
            const columns = table.fields.filter(f => !this.isAutoGeneratedField(f)).map(f => f.name);
            const placeholders = columns.map((_, i) => `$${i + 1}`);
            factory += `    const query = \`INSERT INTO ${table.name} (${columns.join(', ')}) VALUES (${placeholders.join(', ')}) RETURNING *\`;\n`;
            factory += `    const values = [${columns.map(col => `data.${col}`).join(', ')}];\n`;
            factory += `    const result = await DatabasePool.query(query, values);\n`;
            factory += `    return result.rows[0];\n`;
            factory += `  }\n\n`;
            factory += `  static async createMany(count: number, overrides: Partial<any> = {}): Promise<any[]> {\n`;
            factory += `    const records = [];\n`;
            factory += `    for (let i = 0; i < count; i++) {\n`;
            factory += `      records.push(await this.create(overrides));\n`;
            factory += `    }\n`;
            factory += `    return records;\n`;
            factory += `  }\n`;
            factory += `}\n\n`;
        }
        return factory;
    }
    generateMongoFactory(template) {
        let factory = `// Database Factory for ${template.name}\n`;
        factory += `import { faker } from '@faker-js/faker';\n`;
        factory += `import { mongoPool } from '../connection-pool';\n\n`;
        for (const table of template.tables) {
            factory += `export class ${this.toPascalCase(table.name)}Factory {\n`;
            factory += `  static async create(overrides: Partial<any> = {}): Promise<any> {\n`;
            factory += `    const data = {\n`;
            for (const field of table.fields) {
                if (this.isAutoGeneratedField(field))
                    continue;
                factory += `      ${field.name}: ${this.generateFactoryFieldValue(field)},\n`;
            }
            factory += `      createdAt: new Date(),\n`;
            factory += `      updatedAt: new Date(),\n`;
            factory += `      ...overrides\n`;
            factory += `    };\n\n`;
            factory += `    const db = mongoPool.getDb();\n`;
            factory += `    const result = await db.collection('${table.name}').insertOne(data);\n`;
            factory += `    return { ...data, _id: result.insertedId };\n`;
            factory += `  }\n\n`;
            factory += `  static async createMany(count: number, overrides: Partial<any> = {}): Promise<any[]> {\n`;
            factory += `    const records = [];\n`;
            factory += `    for (let i = 0; i < count; i++) {\n`;
            factory += `      const record = {\n`;
            for (const field of table.fields) {
                if (this.isAutoGeneratedField(field))
                    continue;
                factory += `        ${field.name}: ${this.generateFactoryFieldValue(field)},\n`;
            }
            factory += `        createdAt: new Date(),\n`;
            factory += `        updatedAt: new Date(),\n`;
            factory += `        ...overrides\n`;
            factory += `      };\n`;
            factory += `      records.push(record);\n`;
            factory += `    }\n\n`;
            factory += `    const db = mongoPool.getDb();\n`;
            factory += `    const result = await db.collection('${table.name}').insertMany(records);\n`;
            factory += `    return records.map((record, index) => ({...record, _id: result.insertedIds[index]}));\n`;
            factory += `  }\n`;
            factory += `}\n\n`;
        }
        return factory;
    }
    generateFactoryFieldValue(field) {
        switch (field.type) {
            case 'string':
                return this.generateFactoryStringValue(field);
            case 'text':
                return 'faker.lorem.paragraph()';
            case 'integer':
            case 'bigint':
                return 'faker.datatype.number({ min: 1, max: 1000 })';
            case 'decimal':
                return 'parseFloat(faker.commerce.price())';
            case 'boolean':
                return 'faker.datatype.boolean()';
            case 'date':
            case 'datetime':
            case 'timestamp':
                return 'faker.date.recent()';
            case 'json':
                return '{ generated: true, timestamp: new Date().toISOString() }';
            case 'uuid':
                return 'faker.datatype.uuid()';
            default:
                return 'null';
        }
    }
    generateFactoryStringValue(field) {
        const fieldName = field.name.toLowerCase();
        if (fieldName.includes('email')) {
            return 'faker.internet.email()';
        }
        else if (fieldName.includes('name')) {
            if (fieldName.includes('first')) {
                return 'faker.person.firstName()';
            }
            else if (fieldName.includes('last')) {
                return 'faker.person.lastName()';
            }
            else {
                return 'faker.person.fullName()';
            }
        }
        else {
            return 'faker.lorem.word()';
        }
    }
    toPascalCase(str) {
        return str.replace(/(?:^|_)(.)/g, (_, char) => char.toUpperCase());
    }
}
exports.SeedGenerator = SeedGenerator;
//# sourceMappingURL=seed-generator.js.map